function getBlog(){
	return blog = {"content": "# 【设计模式】观察者模式\n观察者模式，又叫发布-订阅模式，定义对象间的一对多的依赖关系，使得每当一个对象改变状态时，所有依赖于它的对象都会得到通知并自动更新。\n\n通常，Subject类是主题，它把所有对观察者对象的引用存在了一个集合里，每个主题都可以有任何数量的观察者。抽象主题提供了一个接口，可以增加和删除观察者对象；Observer类是抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己：\n```java\n// 主题Subject\npublic class Subject {\n    //观察者集合\n    private Vector<Observer> oVector = new Vector<>();\n    \n    //增加一个观察者\n    public void addObserver(Observer observer) {\n        this.oVector.add(observer);\n    }\n    \n    //删除一个观察者\n    public void deleteObserver(Observer observer) {\n        this.oVector.remove(observer);\n    }\n    \n    //通知所有观察者\n    public void notifyObserver() {\n        for(Observer observer : this.oVector) {\n            observer.update();\n        }\n    }\n}\n\n\n// 抽象观察者Observer。每一个实现该接口的实现类都是具体观察者。\npublic interface Observer {\n    //更新\n    public void update();\n}\n\n\n// 具体主题。继承Subject类，在这里实现每个主题的具体业务，在具体项目中，该类会有很多变种。\npublic class ConcreteSubject extends Subject {\n    //具体业务\n    public void doSomething() {\n        //业务逻辑代码\n        // …………\n        super.notifyObserver();\n    }\n}\n\n\n// 具体观察者\npublic class ConcreteObserver implements Observer {\n    @Override\n    public void update() {\n        System.out.println(\"收到消息，进行处理\");\n    }\n}\n\n\n// 测试代码\npublic class Test {\n    public static void main(String[] args) {\n        //创建一个主题\n        ConcreteSubject subject = new ConcreteSubject();\n        //定义一个观察者\n        Observer observer = new ConcreteObserver();\n        //观察\n        subject.addObserver(observer);\n        //开始活动\n        subject.doSomething();\n    }\n\n    // 以上测试代码输出结果为：收到消息，进行处理\n}\n```\n\n#### 优点\n* 观察者和被观察者是抽象耦合的\n* 建立了一套触发机制\n\n#### 缺点\n* 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间\n* 如果观察者和观察目标间有循环依赖，可能导致系统崩溃，所以一般采用异步方式\n* 没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的\n\n#### 使用场景\n* 关联行为场景\n* 事件多级触发场景\n* 跨系统的消息变换场景，如消息队列的处理机制", "title": "【设计模式】观察者模式"}
}