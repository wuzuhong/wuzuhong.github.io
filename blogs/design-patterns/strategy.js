function getBlog(){
	return blog = {"content": "# 【设计模式】策略模式\n定义了一组算法，将每个算法都通过类来封装（而不是方法），并且使它们之间可以互换。\n\n接下来将会使用游戏技能来示例。\n\n## 不使用策略模式的代码\n```java\n// 抽象类\npublic abstract class Demo{\n\tprotected String name;\n \n\tprotected abstract void defend();\n \n\tprotected abstract void attack();\n \n    // 更多的方法…………\n}\n\n\n// A类\npublic class DemoA extends Demo{\n    public DemoA(String name){\n\t\tthis.name = name;\n\t}\n \n\t@Override\n\tprotected void defend(){\n\t\tSystem.out.println(\"样子A\");\n\t}\n \n\t@Override\n\tprotected void attack(){\n\t\tSystem.out.println(\"攻击A\");\n\t}\n\n    // 更多的方法…………\n}\n\n\n// 更多的B类、C类、D类…………\n```\n以上代码的问题在于，很多类中的有些方法实现可能都是一样的，会造成很多重复的代码。\n\n## 使用策略模式的代码\n现在我们将以上示例代码通过策略模式进行改造，将游戏的技能使用类来封装：\n```java\n// 防御的接口\npublic interface IDefendBehavior{\n\tvoid defend();\n}\n\n\n// 攻击的接口\npublic interface IAttackBehavior{\n\tvoid attack();\n}\n\n\n// A的防御技能\npublic class DefendTA implements IDefendBehavior{\n\t@Override\n\tpublic void defend(){\n\t\tSystem.out.println(\"防御A\");\n\t}\n}\n\n\n// A的攻击技能\npublic class AttackA implements IAttackBehavior{\n\t@Override\n\tpublic void attack(){\n\t\tSystem.out.println(\"攻击A\");\n\t}\n}\n\n\n// 更多的B、C、D的防御和攻击技能…………\n```\n相应的，测试类代码也要做修改：\n```java\n// 测试抽象类\npublic abstract class Demo{\n\tprotected String name;\n \n\tprotected IDefendBehavior defendBehavior;\n\tprotected IAttackBehavior attackBehavior;\n \n\tpublic Demo setDefendBehavior(IDefendBehavior defendBehavior){\n\t\tthis.defendBehavior = defendBehavior;\n\t\treturn this;\n\t}\n \n\tpublic Demo setAttackBehavior(IAttackBehavior attackBehavior){\n\t\tthis.attackBehavior = attackBehavior;\n\t\treturn this;\n\t}\n\n\tprotected void attack(){\n\t\tattackBehavior.attack();\n\t}\n \n\tprotected void defend(){\n\t\tdefendBehavior.defend();\n\t}\n}\n\n\n// A测试类\npublic class DemoA extends Demo{\n\tpublic DemoA(String name){\n\t\tthis.name = name;\n\t}\n}\n```\n之后，我们就可以这样使用了：\n```java\npublic class Test{\n\tpublic static void main(String[] args){\n\t\tDemo demoA = new DemoA(\"A\");\n\t\tdemoA.setAttackBehavior(new AttackXL())//\n\t\t\t\t.setDefendBehavior(new DefendTBS());\n\n\t\tSystem.out.println(demoA.name + \":\");\n\n\t\tdemoA.run();\n\t\tdemoA.attack();\n\t\tdemoA.defend();\n\t\tdemoA.display();\n\t}\n}\n```\n经过修改，现在所有的技能的实现做到了100%的复用，没有任何的重复代码，并且随便需求需要什么，对于我们来说只需要动态修改一下技能和展示方式，非常完美。\n\n## 策略模式的应用\n\n#### 优点\n* 算法可以自由切换\n* 避免使用多重条件判断（如果不用策略模式我们可能会使用多重条件语句，不利于维护）\n* 扩展性良好，增加一个策略只需实现接口即可\n\n#### 缺点\n* 策略类数量会增多，每个策略都是一个类\n* 所有的策略类都需要对外暴露\n\n#### 使用场景\n* 多个类只有算法或行为上稍有不同的场景\n* 算法需要自由切换的场景\n* 需要屏蔽算法规则的场景", "title": "【设计模式】策略模式"}
}