function getBlog(){
	return blog = {"content": "# 【设计模式】装饰模式\n装饰模式能够动态地给一个对象添加一些额外的能力。就像`FilterInputStream inputStream = new BufferedInputStream(new FileInputStream(null)))`一样，在给`FileInputStream`装饰一层`BufferedInputStream`之后，它就拥有了缓冲区的能力。\n\n装饰模式发挥作用的地方在于，当我们设计好了一个类，我们需要给这个类添加一些其他的能力，并且不希望改变这个类的代码，这时候就是装饰者模式大展雄威的时候了。这里还体现了一个原则：**类应该对扩展开放，对修改关闭**。\n\n## 接下来以游戏装备为例\n```java\n// 装备的接口\npublic interface IEquip{\n\tpublic int caculateAttack();\n \n\tpublic String attack();\n}\n\n\n// 武器\npublic class ArmEquip implements IEquip{\n\t@Override\n\tpublic int caculateAttack(){\n\t\treturn 20;\n\t}\n \n\t@Override\n\tpublic String attack(){\n\t\treturn \"屠龙刀发起一次攻击\";\n\t}\n}\n\n\n// 其他更多的装备\n\n\n// 装饰品的接口\npublic interface IEquipDecorator extends IEquip{\n}\n\n\n// 蓝宝石\npublic class BlueGemDecorator implements IEquipDecorator{\n\tprivate IEquip equip;\n \n\tpublic BlueGemDecorator(IEquip equip){\n\t\tthis.equip = equip;\n\t}\n \n\t@Override\n\tpublic int caculateAttack(){\n\t\treturn 5 + equip.caculateAttack();\n\t}\n \n\t@Override\n\tpublic String attack(){\n\t\treturn \"【镶嵌了蓝宝石】\"+equip.attack();\n\t}\n}\n\n\n// 其他更多的装饰品\n\n\n// 测试代码\npublic class Test{\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\" 一个镶嵌1颗蓝宝石的武器\");\n\t\t// 一个镶嵌1颗蓝宝石的武器，其能力将会更加强大\n\t\tIEquip equip = new BlueGemDecorator(new ArmEquip());\n\t\tSystem.out.println(\"攻击力  : \" + equip.caculateAttack());\n\t\tSystem.out.println(\"攻击 :\" + equip.attack());\n\t}\n}\n```\n对于以上逻辑，可能还会这么设计，但都是错的：\n* 对于镶嵌宝石的武器的每一种可能性都写一个类，例如：镶嵌了1颗蓝宝石的类、镶嵌了6颗红宝石的类等等，这种写法在最初需求不多的时候，还可以忍，但是到后来需求越来越多，镶嵌宝石的武器的种类无穷无尽，所需要创建的类也是无穷无尽的。\n* 写一个超类，然后里面各种set宝石，然后在计算攻击力的地方，使劲的If有哪几种宝石，但是随便添加个武器，又得多写多少个if呢。\n\n## 装饰模式的应用\n\n#### 优点\n* 装饰类和被装饰类可以独立发展，而不会相互耦合。它有效地把类的核心职责和装饰功能分开了\n* 装饰模式是继承关系的一个替代方案\n* 装饰模式可以动态地扩展一个实现类的功能\n\n#### 缺点\n* 多层装饰比较复杂。比如我们现在有很多层装饰，出了问题，一层一层检查，最后发现是最里层的装饰出问题了，想想工作量都害怕\n\n#### 使用场景\n* 需要扩展一个类的功能时\n* 在不想增加很多子类的情况下扩展类时\n* 需要动态地给一个对象增加功能，并可以动态地撤销时\n* 需要为一批的兄弟类进行改装或加装功能时", "title": "【设计模式】装饰模式"}
}