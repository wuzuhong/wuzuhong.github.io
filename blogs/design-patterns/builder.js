function getBlog(){
	return blog = {"content": "# 【设计模式】建造者模式\n就是一步步创建一个对象，可以精细地控制对象的创建过程。\n\nSpring 中的 RestTemplateBuilder 和 Java 中的 StringBuilder 、 StringBuffer 都用到了建造者模式。\n\n## 示例\n```java\npublic class Demo {\n\tprivate String name;\n\tprivate Integer age;\n\n\tpublic Demo(String name, Integer age) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic Integer getAge() {\n\t\treturn age;\n\t}\n\n    // 建造者\n\tpublic static class Builder {\n\t\tprivate String name;\n\t\tprivate Integer age;\n\n\t\tpublic Builder name(String name) {\n\t\t\tthis.name = name;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder age(Integer age) {\n\t\t\tthis.age = age;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Demo build() {\n\t\t\treturn new Demo(this.name, this.age);\n\t\t}\n\t}\n}\n\n\n// 测试代码\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tDemo demo = new Demo.Builder().age(10).name(\"aabb\").build();\n\t\tSystem.out.println(demo);\n\t}\n}\n```\n\n## 建造者模式的应用\n\n#### 优点\n* 封装性。就是客户端不必知道产品内部组成的细节。\n* 建造者独立，易扩展。\n* 便于控制细节风险。可以对建造过程逐步细化，而不对其他模块产生任何影响。\n\n#### 缺点\n* 产品必须有共同点，范围有限制。\n* 如果内部变化复杂，会有很多建造类。\n\n#### 使用场景\n* 相同的方法，不同的执行顺序，会产生不同的事件结果时。\n* 需要生成的对象具有复杂的内部结构时。\n\n#### 与工厂模式的区别\n* 建造者模式更关注于组装的顺序。", "title": "【设计模式】建造者模式"}
}