function getBlog(){
	return blog = {"content": "# 【消息中间件-RocketMQ】客户端的使用\n## 添加依赖\n```xml\n<dependency>\n    <groupId>org.apache.rocketmq</groupId>\n    <artifactId>rocketmq-spring-boot-starter</artifactId>\n    <version>2.2.2</version>\n</dependency>\n```\n\n## 添加配置\n```properties\n# NameServer 的地址\nrocketmq.name-server=localhost:9876\n# 生产组的名称\nrocketmq.producer.group=demo_producer_group\n# 生产者开启消息轨迹\nrocketmq.producer.enable-msg-trace=true\n```\n\n## 代码示例\n#### 消息体对象\n```java\npublic class DemoMessage {\n    private String id;\n    private String name;\n    private String type;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n}\n```\n\n#### 生产者\n```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\n\nimport org.apache.rocketmq.spring.core.RocketMQTemplate;\nimport org.apache.rocketmq.spring.support.RocketMQHeaders;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.messaging.Message;\nimport org.springframework.messaging.support.MessageBuilder;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.annotation.Resource;\n\n@RestController\npublic class DemoProducer {\n\t@Resource\n\tprivate RocketMQTemplate rocketMQTemplate;\n\n\t@GetMapping(\"/produce\")\n\tpublic void produce() {\n\t\tString id = UUID.randomUUID().toString();\n\t\tSystem.out.println(id);\n\n\t\tDemoMessage msg = new DemoMessage();\n\t\tmsg.setId(id);\n\t\tmsg.setName(\"DemoMessage\");\n\t\tmsg.setType(\"DemoType\");\n\n\t\t// 同一个 shardingKey 的消息会被分配到同一个队列中，并按照顺序被消费。为保证同类型中的消息有序性，设置分区标准为当前消息所对应的类型\n\t\tString shardingKey = msg.getType();\n\t\t// 在业务层面为每条消息设置唯一标识码。可以在消息轨迹中将其作为查询条件\n\t\tString key = msg.getId();\n\n\t\t//顺序消息\n\t\trocketMQTemplate.syncSendOrderly(\"demo_topic:demo_tag\",\n\t\t\t\tMessageBuilder.withPayload(msg).setHeader(RocketMQHeaders.KEYS, key).build(), shardingKey);\n\n//\t\t// 延迟消息\n//\t\trocketMQTemplate.syncSendOrderly(\"demo_topic:demo_tag\",\n//\t\t\t\tMessageBuilder.withPayload(msg)\n//\t\t\t\t\t\t.setHeader(RocketMQHeaders.KEYS, key)\n//\t\t\t\t\t\t.setHeader(RocketMQHeaders.DELAY, \"5\") // 延迟投递等级为 5 ，延迟时间为 1 分钟\n//\t\t\t\t\t\t.build(), shardingKey);\n\n//\t\t// 批量消息\n//\t\tList<Message<DemoMessage>> messages = new ArrayList<>();\n//\t\tMessage<DemoMessage> message1 = MessageBuilder.withPayload(msg).setHeader(RocketMQHeaders.KEYS, key).build();\n//\t\tmessages.add(message1);\n//\t\tMessage<DemoMessage> message2 = MessageBuilder.withPayload(msg).setHeader(RocketMQHeaders.KEYS, key).build();\n//\t\tmessages.add(message2);\n//\t\trocketMQTemplate.syncSendOrderly(\"demo_topic:demo_tag\", messages, shardingKey);\n\t}\n}\n```\n\n#### 消费者\n```java\n\nimport org.apache.rocketmq.spring.annotation.ConsumeMode;\nimport org.apache.rocketmq.spring.annotation.MessageModel;\nimport org.apache.rocketmq.spring.annotation.RocketMQMessageListener;\nimport org.apache.rocketmq.spring.core.RocketMQListener;\nimport org.springframework.stereotype.Component;\n\n@Component\n@RocketMQMessageListener(topic = \"demo_topic\", // 主题\n        selectorExpression = \"demo_tag\", // 标签\n        consumerGroup = \"demo_consumer_group\", // 消费组的名称。一般为应用的唯一标识\n        consumeMode = ConsumeMode.ORDERLY, // 消费模式。为保证消息的有序性，所以设置为顺序消费\n        messageModel = MessageModel.CLUSTERING, // 消息模式，为保证任意一条消息只需要被消费组内的任意一个消费者处理即可，所以设置为集群模式\n        enableMsgTrace = true) // 消费者开启消息轨迹\npublic class DemoConsumer implements RocketMQListener<DemoMessage> {\n\n    @Override\n    public void onMessage(DemoMessage msg) {\n        System.out.println(msg.getId());\n        System.out.println(msg.getName());\n    }\n\n}\n```\n\n#### 事务消息生产者\n```java\nimport demo.rocketmq.DemoMessage;\nimport org.apache.rocketmq.spring.core.RocketMQTemplate;\nimport org.apache.rocketmq.spring.support.RocketMQHeaders;\nimport org.springframework.messaging.support.MessageBuilder;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.annotation.Resource;\nimport java.util.UUID;\n\n@RestController\npublic class TransactionProducer {\n\t@Resource\n\tprivate RocketMQTemplate rocketMQTemplate;\n\n\t@GetMapping(\"/transactionproduce\")\n\tpublic void produce() {\n\t\tString id = UUID.randomUUID().toString();\n\t\tSystem.out.println(id);\n\n\t\tDemoMessage msg = new DemoMessage();\n\t\tmsg.setId(id);\n\t\tmsg.setName(\"DemoMessage\");\n\t\tmsg.setType(\"DemoType\");\n\n\t\t// 在业务层面为每条消息设置唯一标识码。可以在消息轨迹中将其作为查询条件\n\t\tString key = msg.getId();\n\n\t\t// 事务消息\n\t\trocketMQTemplate.sendMessageInTransaction(\"demo_topic:demo_tag\",\n\t\t\t\tMessageBuilder.withPayload(msg)\n\t\t\t\t\t\t.setHeader(RocketMQHeaders.KEYS, key)\n\t\t\t\t\t\t.build(), null);\n\t}\n}\n```\n\n#### 事务消息监听器\n```java\nimport org.apache.rocketmq.spring.annotation.RocketMQTransactionListener;\nimport org.apache.rocketmq.spring.core.RocketMQLocalTransactionListener;\nimport org.apache.rocketmq.spring.core.RocketMQLocalTransactionState;\nimport org.springframework.messaging.Message;\n\n@RocketMQTransactionListener\npublic class RocketMQLocalTransactionListenerImpl implements RocketMQLocalTransactionListener {\n\n    /*\n     * 根据本地事务执行结果向 Broker 提交二次确认结果\n     */\n    @Override\n    public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) {\n        // 可以通过查询数据库来判断本地事务是否已经提交\n        // query db\n\n        return RocketMQLocalTransactionState.COMMIT;\n    }\n\n    /*\n     * 事务消息回查\n     */\n    @Override\n    public RocketMQLocalTransactionState checkLocalTransaction(Message msg) {\n        // 可以通过查询数据库来判断本地事务是否已经提交\n        // query db\n\n        return RocketMQLocalTransactionState.COMMIT;\n    }\n}\n```\n", "title": "【消息中间件-RocketMQ】客户端的使用"}
}