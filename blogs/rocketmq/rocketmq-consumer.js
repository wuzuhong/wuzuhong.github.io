function getBlog(){
	return blog = {"content": "# 【消息中间件-RocketMQ】消费者\n\n## 消费组\n如果多个消费者设置了相同的Consumer Group，那么认为这些消费者在同一个消费组内。\n\nRocketMQ有两种消费模式，分别是：\n1. 集群消费模式：任意一条消息只需要被消费组内的任意一个消费者处理即可，所以是消费组内的消费者分担消费这些消息，因此可以通过扩缩消费者数量，来提升或降低消费能力。可以解决多副本下的重复消费问题，但如果是生产者发送了多条重复消息导致消息重复问题，那么只能是通过消费者的幂等性来解决。\n2. 广播消费模式：会将每条消息推送给消费组所有的消费者，保证消息至少被每个消费者消费一次。\n\n在集群消费模式，消息的分配策略包括：\n1. 平均分配策略（默认）\n2. 机房优先分配策略\n3. 一致性hash分配策略\n\n需要注意的是，在集群消费模式下，并不是一味地增加消费者就能提升消费能力的，比如当Topic的总队列数小于消费者的数量时，消费者将分配不到队列，即使消费者再多也无法提升消费能力。\n\n## 消费位点\n在RocketMQ中每个队列都会记录自己的最小位点、最大位点。\n\n针对于消费组，还有消费位点的概念，在集群模式下，消费位点是由客户端提交给服务端保存的，在广播模式下，消费位点是由客户端自己保存的。\n\n一般情况下消费位点正常更新，不会出现消息重复，但如果消费者发生崩溃或有新的消费者加入群组，就会触发重平衡，重平衡完成后，每个消费者可能会分配到新的队列，而不是之前处理的队列。为了能继续之前的工作，消费者需要读取每个队列最后一次提交的消费位点，然后从消费位点处继续拉取消息。但在实际执行过程中，由于客户端提交给服务端的消费位点并不是实时的，所以重平衡就可能会导致消息少量重复。\n\nACK 机制理论上能够保证消息不会丢失，但如果是消费者因为一些其他原因导致一些消息数据丢失，那么可以通过消费位点重置的方式使得 Broker 重新发送某个消费位点之后的所有消息。\n\n## 消费模式\nRocketMQ的消费模式可以大致分为两种，推和拉：\n1. 推是服务端主动推送消息给客户端，优点是及时性较好，但如果客户端没有做好流控，一旦服务端推送大量消息到客户端时，就会导致客户端消息堆积甚至崩溃。\n2. 拉是客户端需要主动到服务端取数据，优点是客户端可以依据自己的消费能力进行消费，但拉取的频率也需要客户端自己控制，拉取频繁容易造成服务端和客户端的压力，拉取间隔长又容易造成消费不及时。\n\n推和拉的客户端代码写法是不一样的。", "title": "【消息中间件-RocketMQ】消费者"}
}