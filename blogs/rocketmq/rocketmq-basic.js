function getBlog(){
	return blog = {"content": "# 【消息中间件-RocketMQ】基本概念\n## 基础模型\n发布-订阅（Pub/Sub）是 RocketMQ 的基础消息模型，而在实际的应用中，消息模型会更复杂，因此 RocketMQ 对基础消息模型进行了扩展，包括：\n* 生产者 (Producer)\n* 消费者 (Consumer)\n* 主题（Topic）：一个主题可以包含多个队列。\n* 队列（MessageQueue）：为了支持高并发和水平扩展，需要对主题进行分区，在 RocketMQ 中这被称为队列。为了消息写入能力的水平扩展。同一主题下的不同队列可以分布在不同的Broker。如果没有重复发送（比如因为服务端没有响应而进行重试），一条消息只会存在在 Topic 的其中一个队列中，消息在队列中按照先进先出的原则存储，每条消息会有自己的位点，每个队列会统计当前消息的总条数，这个称为最大位点 MaxOffset ，队列的起始位置对应的位置叫做起始位点 MinOffset ，队列可以提升消息发送和消费的并发度。\n* 消费组（ConsumerGroup）：为了消息消费能力的水平扩展，相同的 ConsumerGroup 下的消费者主要有两种负载均衡模式，广播模式和集群模式（常用）。在集群模式下，同一个 ConsumerGroup 中的 Consumer 实例是负载均衡消费，比如 ConsumerGroupA 订阅 TopicA ， TopicA 对应 3个队列，则 ConsumerGroupA 中的 Consumer1 消费的是 MessageQueue 0和 MessageQueue 1的消息，ConsumerGroupA 中的 Consumer2 是消费的是MessageQueue2的消息。在广播模式下，同一个 ConsumerGroup 中的每个 Consumer 实例都处理全部的队列，需要注意的是，广播模式下因为每个 Consumer 实例都需要处理全部的消息，因此这种模式仅推荐在通知推送、配置同步类小流量场景使用。\n* Broker：存储、投递、查询消息的服务器。在 Master-Slave 架构中，Broker 分为 Master 与 Slave。一个Master可以对应多个Slave，但是一个Slave只能对应一个Master。Master 与 Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。\n* NameServer：存储Broker集群的注册信息和消息路由信息的服务器。主要包括两个功能，第一个功能是Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活。第二个功能是路由信息管理，每个NameServer将保存关于 Broker 集群的整个路由信息和用于客户端查询的队列信息。Producer和Consumer通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。NameServer为无状态节点，通常会有多个实例部署，各实例间相互不进行信息通讯。Broker向每一台NameServer建立长连接，定时注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。Producer 与 NameServer 集群中的其中一个节点建立长连接，定期从 NameServer 获取Topic路由信息，并向提供 Topic 服务的 Broker-Master 建立长连接，且定时向 Broker-Master 发送心跳，Producer 完全无状态。Consumer 与 NameServer 集群中的其中一个节点建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Broker-Master、Broker-Slave 建立长连接，且定时向 Broker-Master、Broker-Slave发送心跳。Consumer 既可以从 Broker-Master 订阅消息，也可以从Broker-Slave订阅消息。当某个NameServer因某种原因下线了，客户端仍然可以向其它NameServer获取路由信息。\n\n## RocketMQ集群工作流程\n1. 启动NameServer：NameServer启动后监听端口，等待Broker、Producer、Consumer连接，相当于一个路由控制中心。\n2. 启动 Broker：与所有 NameServer 保持长连接，定时发送心跳包。心跳包中包含当前 Broker 信息以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic跟Broker 的映射关系。\n3. 创建 Topic：手动创建需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建Topic。\n4. 生产者发送消息：启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取当前发送的 Topic存在于哪些 Broker 上，轮询从队列列表中选择一个队列，然后与队列所在的 Broker建立长连接从而向 Broker发消息。\n5. 消费者接受消息：跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，然后开始消费消息。\n", "title": "【消息中间件-RocketMQ】基本概念"}
}