# 【Redis-5.0】分布式锁
* 参考1：http://www.redis.cn/topics/distlock.html

分布式锁在很多场景中是非常有用的，不同的进程必须以独占资源的方式实现资源共享就是一个典型的例子。

## Redis单实例实现分布式锁
使用`SET key value NX PX 30000`命令来**获取锁**，这个命令只有在key不存在的时候才能被执行成功（NX选项），并且这个key有一个30秒的自动失效时间（PX选项）。

这个key是特定的，比如商品id，所有的客户端必须是一样的。value是随机的，每一个客户端都不一样并且都是唯一的。

value必须是随机的主要是为了更安全的释放锁，释放锁的时候使用脚本告诉Redis：只有key存在并且存储的值和我指定的值一样才能告诉我删除成功（因为有可能发生key自动失效导致被其他客户端设置了不同的值的情况）。**释放锁**可以通过以下Lua脚本实现：
```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```
使用这种方式释放锁可以避免删除别的客户端获取成功的锁。举个例子：客户端A取得资源锁，但是紧接着被一个其他操作阻塞了，当客户端A运行完毕其他操作后要释放锁时，原来的锁早已超时并且被Redis自动释放，并且在这期间资源锁又被客户端B再次获取到。如果仅使用DEL命令将key删除，那么这种情况就会把客户端B的锁给删除掉。使用Lua脚本就不会存在这种情况，因为脚本仅会删除value等于客户端A的value的key（value相当于客户端的一个签名）。

key的失效时间被称作“锁定有效期”。它不仅是key自动失效时间，而且还是一个客户端持有锁多长时间后可以被另外一个客户端重新获得，同时也要求一个客户端的操作必须在这个失效时间内完成，所以这个失效时间是由客户端操作的时长来决定的。如果没有这个超时时间的话，客户端在释放锁之前宕机了，那么就会导致死锁，其他客户端就再也获取不到这个锁了。

除了`SET`命令之外，`SETNX`命令的作用也非常相似。其语法为：`SETNX key value`。其含义为：将key设置值为value，如果key不存在，这种情况下等同SET命令。当key存在时，什么也不做。SETNX是`SET if Not eXists`的缩写。其返回值为：如果key被成功地设置了则返回 1，如果key没有被设置则返回 0。但是`SETNX`命令没有设置超时时间的参数，如果没有这个超时时间的话，客户端在释放锁之前宕机了，那么就会导致死锁，其他客户端就再也获取不到这个锁了。**所以建议使用`SET`命令，不要使用`SETNX`命令**。

## Redis多实例实现分布式锁
Redis单实例实现分布式锁的实现方式，从表面上看，似乎效果还不错，但是这里有一个问题：这个架构中存在一个严重的单点失败问题。如果Redis挂了怎么办？你可能会说，可以通过增加一个slave节点解决这个问题。但这通常是行不通的。这样做，我们不能实现资源的独享，因为Redis的主从同步通常是异步的。在这种场景（主从结构）中存在明显的竞态：
* 客户端A从master获取到锁
* 在master将锁同步到slave之前，master宕掉了
* slave节点被晋级为master节点
* 客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。安全失效！

Redis官方提供了Redlock算法，以供Redis多实例下分布式锁的实现，算法原理请查看：http://www.redis.cn/topics/distlock.html。java客户端redisson已经实现了这个算法：https://github.com/redisson/redisson

## 是否必须要使用分布式锁？
答案是否定的，需要具体问题具体分析：
* 如果是多个副本对数据库进行**新增**操作，那么可以通过捕获数据库抛出的唯一约束异常，因为主键是唯一的。如果主键不适用，则可以定义其他唯一字段，并为其添加唯一约束
* 如果是多个副本对数据库进行**修改**操作，那么可以通过悲观锁或乐观锁来实现
* 如果是其他与数据库无关的操作，才有可能需要考虑实现分布式锁