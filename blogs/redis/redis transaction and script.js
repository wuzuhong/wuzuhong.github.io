function getBlog(){
	return blog = {"content": "# 【Redis-5.0】事务和脚本\n## 事务\nRedis 事务将会涉及到 MULTI 、 EXEC 、 DISCARD 和 WATCH 这四个命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：\n* 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\n* 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。**注意，这里写的是执行，而不是成功**。\n\nMULTI命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。在EXEC命令调用之前，通过调用DISCARD可以使客户端清空事务队列，并放弃执行事务。\n\nWATCH命令可以为 Redis 事务提供check-and-set（CAS，乐观锁）行为。被WATCH的键会被监视，并会发觉这些键是否被改动过了，如果有至少一个被监视的键在EXEC执行之前被修改了，那么整个事务都会被取消，EXEC返回nil-reply来表示事务已经失败。WATCH命令可以被调用多次，对键的监视从 WATCH 执行之后开始生效，直到调用 EXEC 为止。当 EXEC 被调用时，不管事务是否成功执行，对所有键的监视都会被取消。另外，当客户端断开连接时，该客户端对键的监视也会被取消。使用无参数的 UNWATCH 命令可以手动取消对所有键的监视\n\n#### 事务中的错误\n使用事务时可能会遇上以下两种错误：\n* 事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。\n* 命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。\n\n服务器会对 EXEC 执行之前的命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。至于那些在 EXEC 命令执行之后所产生的错误，并没有对它们进行特别处理：即使事务中有某个/某些命令在执行时产生了错误，事务中的其他命令仍然会继续执行。\n\n#### 为什么 Redis 不支持回滚\n如果有使用关系式数据库的经验，那么“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。\n以下是这种做法的优点：\n* Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面，这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。\n* 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。\n\n## 脚本\nRedis 2.6.0 版本开始内置了 Lua 解释器，可以对 Lua 脚本进行编译和运行。\n\nRedis 保证脚本会以原子性的方式执行：当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。这也意味着，执行一个运行缓慢的脚本并不是一个好主意。写一个跑得很快很顺溜的脚本并不难，因为脚本的运行开销非常少，但是当你不得不使用一些跑得比较慢的脚本时，请小心，因为当这些蜗牛脚本在慢吞吞地运行的时候，其他客户端会因为服务器正忙而无法执行命令。\n\n#### EVAL命令\nEVAL命令就是用来执行脚本的：\n* EVAL的第一个参数是一段 Lua 5.1 脚本程序，这段Lua脚本不需要（也不应该）定义函数，它运行在 Redis 服务器中。\n* EVAL的第二个参数是键名参数的个数，后面的参数（从第三个参数开始）则是在脚本中会用到的那些 Redis 键（key），这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问（KEYS[1]、KEYS[2]等等，以此类推）。\n* 在命令的最后，是那些不是键名参数的附加参数 arg [arg …]，可以在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似（ARGV[1]、ARGV[2]等等，以此类推）。\n\n例如：\n```\nEVAL \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\" 2 key1 key2 arg1 arg2\n```\n\n#### KEYS 和 ARGV 的区别\n建议 KEYS 中放 Redis 数据中的键， ARGV 中放当前脚本需要的额外参数。\n\n对于 KEYS 中放 Redis 数据中的键，是因为所有的 Redis 命令，在执行之前都会被分析，以此来确定命令会对哪些键进行操作，比如一个特别重要的用途就是确保 Redis 集群可以将请求发送到正确的集群节点。\n\n#### EVALSHA命令\nEVAL命令要求在每次执行脚本的时候都发送一次脚本主体，而 Redis 有一个内部的缓存机制，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。\n\n为了减少带宽的消耗，Redis 实现了 EVALSHA 命令，它的作用和 EVAL 一样，都用于对脚本求值。但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)，其他的参数和EVAL命令是一样的。例如：\n```\nEVALSHA 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 2 key1 key2 arg1 arg2\n```\n\nEVALSHA 命令表现为：如果服务器还记得给定的 SHA1 校验和所指定的脚本，那么执行这个脚本。如果服务器不记得给定的 SHA1 校验和所指定的脚本，那么它返回一个特殊的错误，提醒用户使用 EVAL 代替 EVALSHA。\n\n## Redis 脚本和事务的区别\n从定义上来说， Redis 中的脚本本身就是一种事务，所以任何在事务里可以完成的事，在脚本里面也能完成。并且一般来说，使用脚本要来得更简单，并且速度更快。\n\n所以答案是：没啥区别。只是因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了，所以 Redis 才会同时存在两种处理事务的方法。", "title": "【Redis-5.0】事务和脚本"}
}