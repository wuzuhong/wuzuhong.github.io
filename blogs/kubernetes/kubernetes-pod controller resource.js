function getBlog(){
	return blog = {"content": "# 【kubernetes】pod控制器资源\n## pod控制器的作用\n用于实现代替用户管理pod的中间层，并确保每一个pod资源始终处于我们所定义或者所期望的目标状态，如果万一pod出现了故障，那么这个pod的控制器首先会尝试去重启容器，如果重复重启多次还是有问题的话，那么它会根据某种策略，来对pod进行重新编排，如果pod的副本数量低于目标数量，那么它会自动补全，如果pod的副本数量多余目标数量，那么它会自动杀死多余的pod资源。\n\n## pod控制器的类型\n* ReplicaSet ：可以代替用户来创建指定数量的pod副本，并确保pod副本数量一直处于用户所期望的状态，多退少补，并支持自动扩缩容机制，它主要由三个属性组成：用户期望的pod副本、标签选择器、pod资源模板（用于新建pod），kubernetes不建议使用ReplicaSet，而建议使用Deploymet。\n* Deploymet ：Deploymet是工作在ReplicaSet之上，也就是说Deploymet并不是直接控制pod，而是控制ReplicaSet，Deploymet支持自动扩缩容、滚动更新、回滚等机制，而且它还支持声明式配置的功能，它是用来管理无状态pod的最好的控制器（无状态指的是只关注群体而不关注个体，无论哪个挂了都可以找其他的替代）。\n* DaemonSet ：用于确保集群中的每一个节点只运行一个特定的pod副本，因此它的副本数是随集群规模而自动变动的，通常用来实现一些系统级的管理任务，属于守护进程，这些进程不会被终止。\n* Job ：按照用户指定的pod数量来启动指定数量的pod资源，这些pod资源启动后就开始执行指定的任务，若还没有完成这个任务，pod就挂了，那么它会重建出新的pod，若任务已经完成，那么这些pod也就正常退出和销毁了。用于某些一次性运行的pod。\n* Cronjob ：跟Job不同的是，这个控制器中的pod是周期性运行。Job、Cronjob与DaemonSet的显著区别就是他们不需要持续后台运行。\n* StatefulSet ：能够管理有状态的应用（比如数据库），其中的每一个pod副本都是被单独管理的，一旦有一个pod挂了，在重建这个pod的时候，它会做很多初始化操作（比如数据迁移）。由于每一种应用的初始化操作都不一样，因此StatefulSet允许我们对这些操作进行封装，就是把我们需要手动执行的操作定义成脚本放置在StatefulSet的pod模板的定义当中，但是这些操作脚本写起来很复杂，若脚本有一个错误，很可能导致整个集群都崩溃，因此有状态的应用放在k8s中需要特别小心。现在有一个开源框架叫Vitess可以很好的支持MySQL的集群化部署，京东80%的数据库都基于这个框架跑在docker里面，并由k8s进行调度和管理。\n  \n## pod控制器详解\n### ReplicaSet\n\n查看ReplicaSet的定义方式，可以一直点下去\n```\nkubectl explain rs\n```\n\n查看已创建的ReplicaSet\n```\nkubectl get rs -o wide\n```\n\n当我们去删除一个pod的时候， ReplicaSet会帮我们重新建一个pod，以维持期望的副本数。当前副本数大于期望的副本数时， ReplicaSet会进行删除，直到副本数为期望的副本数。\n\n若想彻底删除pod，必须删除ReplicaSet\n```\nkubectl delete rs nginx-replicaset\n```\n\nReplicaSet是通过标签选择器来选择当前的副本的，因此在定义pod资源的标签的时候要特别小心，不能冲突，否则当前pod就有可能会变成其他控制器的副本，就有可能会被其他控制器删除。\n\n编辑ReplicaSet的资源定义\n```\nkubectl edit rs nginx-replicaset\n```\n如果只修改了pod的镜像版本号，那么在ReplicaSet是不会生效的，因为pod资源不会因为这个修改而重建，如果把pod删了，让ReplicaSet自动去重建，那么重建之后的pod就是新版本的了。删一个再重建一个新版本，这就叫灰度发布。\n\n### Deploymet\n\n![Deployment资源](./images/kubernetes-Deployment.png)\n\nDeployment在实现滚动更新时是根据定义的副本浮动数来实现不同的更新逻辑的；若定义了在更新时只允许少一个，那么就是上图中的先删一个，再加一个；若定义了在更新时只允许多一个，那么就是先加一个，再删一个；若定义了在更新时即允许少一个，又允许多一个，那么就是先加一个，再删两个，再加两个，再删两个，……；Deployment默认的更新策略为滚动更新。\n\n查看Deployment的定义方式，可以一直点下去\n```\nkubectl explain deploy\n```\n\n查看已创建的Deployment资源\n```\nkubectl get deploy -o wide\n```\n\n可以通过编辑deployment资源定义yaml文件，然后再更新deployment资源，从而实现动态更新deployment资源的配置，包括镜像版本号\n```\nvi deploy-demo.yml\nkubectl apply -f deploy-demo.yml\n```\n\n查看当前已创建的某个deployment资源的详细信息\n```\nkubectl describe deploy nginx-deploy\n```\n\n查看可以回滚的deployment版本\n```\nkubectl rollout history deploy nginx-deploy\n```\n\n回滚到deployment到上一个版本\n```\nkubectl rollout undo deploy nginx-deploy\n```\n\n回滚到deployment到指定版本\n```\nkubectl rollout undo deploy nginx-deploy --to-revision=3\n```\n\n### DaemonSet\n\n查看DaemonSet的定义方式，可以一直点下去\n```\nkubectl explain ds\n```\n\n查看已创建的DaemonSet资源\n```\nkubectl get ds -o wide\n```\n\nDaemonSet也支持滚动更新。\n\n### statefulset\n\nStatefulSet的意思是有状态的应用副本集。\n\n对于无状态的应用，只关注群体，其中一个宕机了，用另一个替换即可；\n对于有状态的应用，只关注个体，他们有以下特点：\n1、稳定且需要有唯一的网络标识符；\n2、有稳定且持久存储的设备；\n3、有序、平滑的部署和扩展；（扩容是顺序的）\n4、有序、平滑的终止和删除；（缩容是逆序的）\n5、有序的滚动更新。\n\n有状态的应用需要用到三个组件：headless service（无头服务）、StatefulSet（statefulset控制器）、volumeClaimTemplate（存储卷申请模板）。\n有状态的应用的pod的名称必须保证唯一且固定，headless service就是做这个事情的；大多数有状态的应用都需要持久存储，volumeClaimTemplate就是做这个事情的；\n\n要想创建一个有状态的应用副本集，实际上是很困难的，因此可以查看网上别人的示例和模板，例如想创建一个redis的statefulset的话，可搜索：redis statefulset", "title": "【kubernetes】pod控制器资源"}
}