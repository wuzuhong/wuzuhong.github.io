function getBlog(){
	return blog = {"content": "# 【kubernetes】pod资源\n## pod的生命周期\n* 在 MainContainer 创建之前。这个阶段可以在这个 pod 中启动另外一个容器来为 MainContainer 进行环境初始化，这个容器一般叫做 InitContainer，InitContainer 可以有多个，需要按顺序执行，并且在执行完成后会被销毁。\n* 在 MainContainer 创建成功但没有启动时（称为PostStart）。这个阶段可以人为的做一些操作。在 PostStart 结束后，可以做两类检测，liveness probe（存活状态检测，用于探测主容器是否处于运行状态）和 readiness probe（就绪状态检测，用于探测容器中的主进程是否准备就绪并可以对外提供服务）；一个容器存活了并不代表它就绪了，因为就绪指的是能够对外提供服务了；一般来说，所有的pod中的所有容器都需要做liveness probe和readiness probe的，因为外部请求是通过service来转发到pod上的，而pod如果没有存活或者就绪，那么很多用户的请求都会失败，而如果做了liveness probe和readiness probe的话，一旦检测错误，service是不会关联当前pod的，而用户的请求就会转发到其他状态检测通过的pod之上。\n* 在 MainContainer 即将停止时（称为PreStop）。这个阶段可以人为的做一些操作。\n\n## 常见的pod状态\n* Pending ：挂起状态，主要是因为调度没有完成。\n* Running ：运行状态。\n* Failed ：失败状态。\n* Succeeded ：成功状态，该状态存在的时间很短。\n* Unknown ：未知状态，因为 pod 的状态是由 master 节点上的 apiserver 与 node 节点上的 kubelet 进行通信来获取到的，如果通信失败，就会变成未知状态。\n\n查看某个pod资源当前的详细状态：\n```\nkubectl describe pods pod-demo\n```\n\n## 创建pod的过程\n* 首先用户将创建pod的请求提交给apiserver；\n* 然后apiserver先将这个创建请求的目标状态保存在etcd当中；\n* 随后apiserver会请求scheduler进行调度；\n* 然后scheduler会挑选出一个合适的节点，并把调度结果保存并更新在etcd中；\n* 随后目标node节点上的kubelet监听到etcd中的状态变化会知道有一个新任务分配给自己了，此时这个node节点会拿到用于请求创建pod时所提供的资源清单，根据清单在当前node节点上启动pod，如果pod启动成功或者失败了，都会将这个pod的状态发送给apiserver；\n* 最后由apiserver将该pod的状态保存在etcd当中。", "title": "【kubernetes】pod资源"}
}