function getBlog(){
	return blog = {"content": "# 【kubernetes】service资源\n## service资源的工作模式\n* userspace\n\n![service的工作模式—userspace](./images/kubernetes-service-userspace.png)\n\n* iptables\n\n![service的工作模式—iptables](./images/kubernetes-service-iptables.png)\n\n* ipvs（默认的工作模式）\n\n![service的工作模式—ipvs](./images/kubernetes-service-ipvs.png)\n\n## service资源的类型\n* ExternalName ：让集群内部可以访问集群外部的服务。\n* ClusterIP（默认） ：让集群内部之间可以互相访问。\n* NodePort ：让集群外部可以访问集群内部的服务，可以通过集群内任意节点的ip加上service暴露的随机端口进行访问。\n* LoadBalancer ：用于自动在集群外部创建负载均衡器。\n\n## 创建service资源\n查看service资源的定义方式，可以一直点下去\n```\nkubectl explain service\n```\n\n定义service资源的yaml文件示例，service-demo.yml ：\n```\n#用于指定当前创建的资源所属的 api 群组及其版本，一般为组名/版本的形式，\n#可以使用 kubectl api-versions 命令来获取所有可用的apiVersion\napiVersion: v1\n#资源类型\nkind: Service\n#元数据\nmetadata:\n  #资源的名称，在同一个名称空间中的同一个资源类型下的资源的名称必须唯一  \n  name: redis-service\n  #资源的名称空间\n  namespace: default \nspec: \n  #service的类型\n  type: ClusterIP\n  ports: \n    - port: 6379\n      targetPort: 6379\n  #标签选择器，用于选择要被当前 service 所代理的 pod 资源\n  selector: \n    app: redis\n```\n\n定义好service资源的yaml文件后就可以创建service资源了\n```\nkubectl apply -f service-demo.yml\n```\n\n查看当前已创建的service资源\n```\nkubectl get svc -o wide\n```\n\n查看某个已创建的service资源的详细信息；\n```\nkubectl describe svc redis-service\n```", "title": "【kubernetes】service资源"}
}