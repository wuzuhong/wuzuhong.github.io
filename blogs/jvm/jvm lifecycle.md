# 【jvm详解】基本原理

## JVM的生命周期
JVM实例对应了一个独立运行的java程序，它是进程级别的：
1. 启动。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点。
2. 运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，当然，java程序也可以标明自己创建的线程是守护线程。
3. 消亡。当程序中的所有非守护线程都终止时，JVM才退出。若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。

## JVM的体系结构
* 类加载器（ClassLoader，用来加载.class文件，也就是字节码文件）
* 执行引擎（执行字节码，或者执行本地方法）
* 运行时内存区域（方法区、堆、java栈、PC寄存器、本地方法栈）

## java对象的创建过程

1. 类加载检查： JVM 虚拟机遇到一条 new 指令时，将去检查这个类是否已被类加载器加载过，如果没有，那必须先执行相应类的加载过程。
2. 分配内存：对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有“指针碰撞”和“空闲列表”两种。选择这两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是“标记-清除”，还是“标记-整理”。
3. 初始化零值：虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
4. 设置对象头：虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象头中。
5. 执行init方法：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，执行 new 指令之后需要接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

## 判断 java 对象不再被使用的方式

1. 引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于 0 时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时 GC 没法回收。
2. 可达性分析计算：这是一种类似于二叉树的实现，通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到 GC Roots 没有任何的引用链相连时（从 GC Roots 到这个对象不可达），则说明该对象是不会再次使用的。 Java 就是用这种方式的。在 Java 中能作为 GC Roots 的对象包括虚拟机栈中引用的对象、方法区中静态变量引用的对象、方法区中常量引用的对象、本地方法栈JNI引用的对象、已启动的且未终止的Java线程。

当对象被判定为不再被使用后，将有垃圾回收算法进行GC操作。