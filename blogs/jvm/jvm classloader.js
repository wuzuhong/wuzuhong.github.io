function getBlog(){
	return blog = {"content": "# 【jvm详解】类加载器\n\n类加载器（ClassLoader）是负责将`.class`文件加载到jvm的运行时数据区的方法区中。类加载器只负责`.class`文件的加载，是否能够运行是由执行引擎（ExecutionEngine）来决定的。\n\n## 类的加载过程\n1. 加载：通过全类名获取定义此类的二进制字节流，将字节流所代表的静态存储结构转换为方法区的运行时数据结构，在内存中生成一个代表该类的 Class 对象，作为方法区对这些数据的访问入口。在这一步可以通过自定义类加载器并重写类加载器的loadClass方法去控制字节流的获取方式。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。\n2. 验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件。\n3. 准备：为静态变量在方法区中分配内存并设置静态变量初始值的阶段。对于基本数据类型的静态变量的初始值通常情况设置的是其默认的零值（如 0、0L、null、false 等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是 111，初始化阶段才会赋值为 111。特殊情况，比如给 value 变量加上了 final 关键字public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。注意，准备阶段并不涉及实例变量，实例变量是在对象实例化时随对象一起分配在堆中。\n4. 解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如import java.util.ArrayList就是符号引用，直接引用就是指针，注意引用对象一定是在内存进行），也就是得到类、字段、方法在内存中的指针。\n5. 初始化：就是执行类构造器方法`<clinit>()`的过程，而且要保证执行前父类的`<clinit>()`方法执行完毕，`<clinit>()`方法是编译之后自动生成的。只有主动去使用类才会初始化类。\n\n其中验证、准备、解析这三个统称为连接。加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。\n\n## 类的生命周期\n类的生命周期是在类的加载过程的基础之上加上以下两个过程：\n6. 使用。\n7. 卸载：也就是该类的 Class 对象被 GC。在此之前必须保证该类的所有的实例对象都已被 GC、该类没有在其他任何地方被引用、该类的类加载器的实例已被 GC。\n\n## 类加载器的层次顺序\n* BootStrapClassLoader ：加载jre核心jar包中的类（java.lang.*等）。\n* ExtensionClassLoader : 加载jre扩展jar包中的类。\n* AppClassLoader ：加载classpath下jar包中的类。\n* CustomClassLoader ：自定义的类加载器，不一定存在，只有自己定义了才会存在。\n\n## 双亲委派机制\n双亲委派机制和类加载器的层次顺序是由密切关联的。如果不考虑CustomClassLoader，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，AppClassLoader的父加载器是ExtensionClassLoader，然后调用父加载器的loadClass方法，父加载器中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达BootstrapClassLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，就会反过来下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。所以这里是包含两个过程的：\n* 检查是否已经加载该类的过程： AppClassLoader -> ExtensionClassLoader -> BootStrapClassLoader。\n* 自己加载该类的过程： BootStrapClassLoader -> ExtensionClassLoader -> AppClassLoader。\n\n双亲委派机制的优势：\n* 避免自己写的代码影响jre中的代码，比如自己定义的java.lang.String类不会被加载。\n* 避免类的重复加载，当父加载器已经加载了该类的时候，就不需要子加载器再加载一次。", "title": "【jvm详解】类加载器"}
}