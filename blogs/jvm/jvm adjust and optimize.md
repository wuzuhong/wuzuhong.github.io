# 【jvm详解】性能调优
对JVM的调优主要是针对垃圾收集器的性能优化，使得运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量，主要是通过减少Full GC的频率来实现。

Full GC会对整个堆进行整理，包括新生代和旧生代，因为需要对整个堆进行回收，所以比较慢，因此应该尽可能减少Full GC的次数。

触发 Full GC 的条件：
* 旧生代被写满
* System.gc()被显示调用

## 监控GC的状态
使用各种JVM工具（例如：Arthas），查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和GC日志，根据实际的各区域内存划分和GC执行时间，从而分析是否需要进行优化。

系统崩溃前的一些现象：
* 每次minor GC的时间越来越长，由之前的10ms延长到50ms左右；Full GC的时间也有之前的0.5s延长到5s
* FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC
* 旧生代的内存越来越大并且每次FullGC后旧生代内存没有被充分释放

出现以上现象之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值，这个时候就需要分析JVM内存快照dump。

#### 分析dump文件
需要打开这个3G的dump文件，显然一般的Window系统没有这么大的内存，建议使用Eclipse专门的静态内存分析工具Mat打开分析。

#### 分析结果，判断是否需要优化
如果各项参数设置合理，系统没有超时日志出现，Full GC频率不高，Full GC耗时不高，那么没有必要进行优化，如果Full GC时间超过2秒，或者频繁GC，则必须优化。

如果满足下面的指标，则一般不需要进行优化：
* Minor GC执行时间不到50ms
* Minor GC执行不频繁，约10秒一次
* Full GC执行时间不到1s
* Full GC执行频率不算频繁，不低于10分钟1次

#### 不断的分析和调整
调整JVM参数，通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。

## JVM参数调优参考

#### JVM堆的设置
针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值。

对于Java8来说，通常情况下，默认堆内存的初始容量为物理内存大小的1/64，最大内存不超过物理内存的1/4。

####  新生代和旧生代的设置
新生代和旧生代将根据默认的比例（1：2）分配堆内存，可以通过调整二者之间的比率来调整二者之间的大小，也可以设置绝对值：比如新生代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止新生代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。

#### 新生代和旧生代设置多大才算合理
* 更大的新生代必然导致更小的旧生代，大的新生代会延长minor GC的周期，但会增加每次minor GC的时间；小的旧生代会导致更频繁的Full GC
* 更小的新生代必然导致更大的旧生代，小的新生代会导致minor GC很频繁，但每次的minor GC时间会更短；大的旧生代会减少Full GC的频率

如何选择应该取决于应用程序中对象生命周期的分布情况：如果应用存在大量的临时对象，应该选择更大的新生代；如果存在相对较多的持久对象，旧生代应该适当增大。但很多应用都没有这样明显的特性。

在抉择时应该根据以下两点：
* 本着Full GC尽量少的原则，让旧生代尽量缓存常用对象，JVM的默认比例1：2也是这个道理。
* 通过观察应用一段时间，看看在峰值时旧生代会占多少内存，在不影响Full GC的前提下，根据实际情况加大新生代，比如可以把比例控制在1：1，但应该给旧生代至少预留1/3的增长空间。

#### 在配置较好的机器上的做法
在配置较好的机器上（比如多核、大内存），可以为旧生代选择并行收集算法：-XX:+UseParallelOldGC 。

#### 线程堆栈的设置
每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太大了，一般256K就足用。

理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。