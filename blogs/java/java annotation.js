function getBlog(){
	return blog = {"content": "# 【java基础】Java注解\n转载自：\n* https://www.cnblogs.com/throwable/p/9139908.html  \n* https://blog.csdn.net/weixin_33768481/article/details/88606099\n\n## 概述\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface AnnotationDemo {\n\tString name();\n\n\tString desc() default \"\";\n}\n```\n以上是一个注解的定义示例。首先可以看到`@AnnotationDemo`注解上有`@Documented`、`@Retention`和`@Target`三个注解，这些注解了注解的注解，称之为元注解。然后可以看到注解是以`@interface`关键字来标识的。最后可以看到`String name();`和`String desc() default \"\";`两行代码，称之为注解元素，注解元素有两种声明方式：`元素类型 元素名称`和`元素类型 元素名称 元素的默认值`。\n\n## 常见的元注解\n\n#### @Documented\n主要用于文档工具的识别，被注解的元素能被Javadoc或类似的工具文档化\n\n#### @Retention\n指定该注解的保留策略，可选的保留策略为：\n* `RetentionPolicy.SOURCE`：表示只保留在源码阶段，会被编译器丢弃\n* `RetentionPolicy.CLASS`：表示会被编译器保留到class文件中，但是在运行阶段不会被JVM保留\n* `RetentionPolicy.RUNTIME`：表示会被编译器保留到class文件中，并且在运行阶段也会被JVM保留\n\n#### @Target\n主要用于限制该注解能够应用在哪些项上，没有加`@Target`的注解可以应用于任何项上，可选的项为：\n* `ElementType.TYPE`：表示只能用于类上\n* `ElementType.FIELD`：表示只能用于字段上\n* `ElementType.METHOD`：表示只能用于方法上\n* `ElementType.PARAMETER`：表示只能用于参数上\n* `ElementType.CONSTRUCTOR`：表示只能用于构造函数上\n* `ElementType.LOCAL_VARIABLE`：表示只能用于局部变量上\n* `ElementType.ANNOTATION_TYPE`：表示只能用于注解上\n* `ElementType.PACKAGE`：表示只能用于包上\n* `ElementType.TYPE_PARAMETER`：表示只能用于类型参数上，也就是类的泛型上\n* `ElementType.TYPE_USE`：表示只能用于声明类型的地方，例如类型转换\n\n#### @Inherited\n添加了@Inherited注解的类，其子类也将拥有这个注解\n\n#### @Repeatable\n表示注解是可重复使用的，也就是可以多次应用于相同的声明或类型，也就是让同一个注解可以重复在同一类/方法/属性上使用，示例：\n```java\n// Schedule.java\n// 重复注解类\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Repeatable(Schedules.class)\npublic @interface Schedule {\n    String dayOfMonth() default \"first\";\n    String dayOfWeek() default \"Mon\";\n    int hour() default 12;\n}\n\n// Schedule.java\n// 容器注解类\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface Schedules {\n    Schedule[] value();\n}\n\n// RepetableAnnotationTest.java\n// 测试类\n@Schedule(dayOfMonth=\"last\")\n@Schedule(dayOfWeek=\"Wed\", hour=24)\npublic class RepetableAnnotationTest{\n    @Schedule(dayOfMonth=\"last\")\n    @Schedule(dayOfWeek=\"Fri\", hour=23)\n    public void doPeriodicCleanup(){\n    }\n\n    public static void main(String[] args) throws NoSuchMethodException {\n        Method doPeriodicCleanup = RepetableAnnotation.class.getMethod(\"doPeriodicCleanup\");\n        Schedules schedules = doPeriodicCleanup.getAnnotation(Schedules.class);\n        System.out.println(\"获取标记方法上的重复注解：\");\n        for (Schedule schedule: schedules.value()){\n            System.out.println(schedule);\n        }\n        System.out.println(\"获取标记类上的重复注解：\");\n        if (RepetableAnnotation.class.isAnnotationPresent(Schedules.class)){\n            schedules = RepetableAnnotation.class.getAnnotation(Schedules.class);\n            for (Schedule schedule: schedules.value()){\n                System.out.println(schedule);\n            }\n        }\n    }\n}\n```\n\n## 插件化注解处理API（Pluggable Annotation Processing API）\n**它的作用在于：能够在编译期对源码进行自定义操作，该操作将会在编译后的字节码文件中体现**\n\n它的核心是`Annotation Processor`，即注解处理器，一般需要继承抽象类`javax.annotation.processing.AbstractProcessor`。注意，与运行时注解`RetentionPolicy.RUNTIME`不同，注解处理器只会处理源码阶段的注解，也就是RetentionPolicy.SOURCE的注解类型，处理的操作会在Java代码编译时触发，并且会在编译完成之前结束处理操作，所以可以在处理器中对源码进行自定义操作，该操作将会在编译后的字节码文件中体现。\n\n#### 使用步骤\n1. 自定义一个Annotation Processor，需要继承javax.annotation.processing.AbstractProcessor，并重写process方法。\n2. 自定义一个注解，在注解的元注解部分需要指定@Retention(RetentionPolicy.SOURCE)。\n3. 需要在声明的自定义Annotation Processor中使用javax.annotation.processing.SupportedAnnotationTypes指定在第2步创建的注解类型的名称(注意需要全类名，\"包名.注解类型名称\"，否则会不生效)。\n4. 需要在声明的自定义Annotation Processor中使用javax.annotation.processing.SupportedSourceVersion指定java版本。\n5. 可选操作，可以通在声明的自定义Annotation Processor中使用javax.annotation.processing.SupportedOptions指定编译参数。\n\n#### 配置Processor\n为了让自定义的Processor起作用，需要指定其位置，可以通过下面任意一种方式来指定Processor：\n1. 直接使用编译参数指定，例如：javac -processor demo.AnnotationProcessor Main.java。\n2. 通过服务注册指定，就是META-INF/services/javax.annotation.processing.Processor文件中添加demo.AnnotationProcessor。\n3. 通过Maven的编译插件的配置指定如下：\n    ```xml\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.5.1</version>\n        <configuration>\n            <source>1.8</source>\n            <target>1.8</target>\n            <encoding>UTF-8</encoding>\n            <annotationProcessors>\n                <annotationProcessor>\n                    demo.AnnotationProcessor\n                </annotationProcessor>\n            </annotationProcessors>\n        </configuration>\n    </plugin>\n    ```\n    值得注意的是，以上方式生效的前提是demo.AnnotationProcessor已经被编译过，否则编译的时候就会报错。解决方法有两种，第一种是提前使用命令或者IDEA右键demo.AnnotationProcessor对它进行编译；第二种是把demo.AnnotationProcessor放到一个独立的Jar包引入；**推荐使用第二种方式解决**。\n\n#### 使用示例\n下面是一个直接修改类代码的例子，为实体类的Setter方法对应的属性生成一个Builder类，也就是原来的类如下：\n```java\npublic class Person {\n\n    private Integer age;\n    private String name;\n\n    public Integer getAge() {\n        return age;\n    }\n\n    @Builder\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    @Builder\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n将会生成的Builder类如下：\n```java\npublic class PersonBuilder {\n \n    private Person object = new Person();\n \n    public Person build() {\n        return object;\n    }\n \n    public PersonBuilder setName(java.lang.String value) {\n        object.setName(value);\n        return this;\n    }\n \n    public PersonBuilder setAge(int value) {\n        object.setAge(value);\n        return this;\n    }\n}\n```\n自定义的注解如下：\n```java\n@Target({ElementType.METHOD})\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Builder {\n\n}\n```\n自定义的注解处理器如下：\n```java\n@SupportedAnnotationTypes(value = {\"demo.Builder\"})\n@SupportedSourceVersion(value = SourceVersion.RELEASE_8)\npublic class BuilderProcessor extends AbstractProcessor {\n\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        for (TypeElement typeElement : annotations) {\n            Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith(typeElement);\n            Map<Boolean, List<Element>> annotatedMethods\n                    = annotatedElements.stream().collect(Collectors.partitioningBy(\n                    element -> ((ExecutableType) element.asType()).getParameterTypes().size() == 1\n                            && element.getSimpleName().toString().startsWith(\"set\")));\n            List<Element> setters = annotatedMethods.get(true);\n            List<Element> otherMethods = annotatedMethods.get(false);\n            otherMethods.forEach(element ->\n                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,\n                            \"@Builder must be applied to a setXxx method \"\n                                    + \"with a single argument\", element));\n            Map<String, String> setterMap = setters.stream().collect(Collectors.toMap(\n                    setter -> setter.getSimpleName().toString(),\n                    setter -> ((ExecutableType) setter.asType())\n                            .getParameterTypes().get(0).toString()\n            ));\n            String className = ((TypeElement) setters.get(0)\n                    .getEnclosingElement()).getQualifiedName().toString();\n            try {\n                writeBuilderFile(className, setterMap);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return true;\n    }\n\n    private void writeBuilderFile(\n            String className, Map<String, String> setterMap)\n            throws IOException {\n        String packageName = null;\n        int lastDot = className.lastIndexOf('.');\n        if (lastDot > 0) {\n            packageName = className.substring(0, lastDot);\n        }\n        String simpleClassName = className.substring(lastDot + 1);\n        String builderClassName = className + \"Builder\";\n        String builderSimpleClassName = builderClassName\n                .substring(lastDot + 1);\n\n        JavaFileObject builderFile = processingEnv.getFiler().createSourceFile(builderClassName);\n\n        try (PrintWriter out = new PrintWriter(builderFile.openWriter())) {\n\n            if (packageName != null) {\n                out.print(\"package \");\n                out.print(packageName);\n                out.println(\";\");\n                out.println();\n            }\n            out.print(\"public class \");\n            out.print(builderSimpleClassName);\n            out.println(\" {\");\n            out.println();\n            out.print(\"    private \");\n            out.print(simpleClassName);\n            out.print(\" object = new \");\n            out.print(simpleClassName);\n            out.println(\"();\");\n            out.println();\n            out.print(\"    public \");\n            out.print(simpleClassName);\n            out.println(\" build() {\");\n            out.println(\"        return object;\");\n            out.println(\"    }\");\n            out.println();\n            setterMap.forEach((methodName, argumentType) -> {\n                out.print(\"    public \");\n                out.print(builderSimpleClassName);\n                out.print(\" \");\n                out.print(methodName);\n\n                out.print(\"(\");\n\n                out.print(argumentType);\n                out.println(\" value) {\");\n                out.print(\"        object.\");\n                out.print(methodName);\n                out.println(\"(value);\");\n                out.println(\"        return this;\");\n                out.println(\"    }\");\n                out.println();\n            });\n            out.println(\"}\");\n        }\n    }\n}\n```\n测试主类如下：\n```java\npublic class Main {\n\n    public static void main(String[] args) throws Exception{\n      //PersonBuilder在编译之后才会生成，这里需要编译后才能这样写\n      Person person  = new PersonBuilder().setAge(25).setName(\"doge\").build();\n    }\n}\n```\n先手动编译BuilderProcessor，然后在META-INF/services/javax.annotation.processing.Processor文件中添加demo.BuilderProcessor，最后执行Maven命令mvn compile进行编译。\n\n编译成功之后，target/classes包下面的demo子包路径中会新增了一个类PersonBuilder：\n```java\npublic class PersonBuilder {\n    private Person object = new Person();\n\n    public PersonBuilder() {\n    }\n\n    public Person build() {\n        return this.object;\n    }\n\n    public PersonBuilder setName(String value) {\n        this.object.setName(value);\n        return this;\n    }\n\n    public PersonBuilder setAge(Integer value) {\n        this.object.setAge(value);\n        return this;\n    }\n}\n```\n\n**注意**：就算把保留策略更改为`RetentionPolicy.CLASS`或`RetentionPolicy.RUNTIME`，以上的注解处理器也能起作用，这是因为`RetentionPolicy.CLASS`或`RetentionPolicy.RUNTIME`会保留的注解，同样也会在`RetentionPolicy.SOURCE`中保留。", "title": "【java基础】Java注解"}
}