function getBlog(){
	return blog = {"content": "# 【java基础】Java泛型\nJava 的泛型是伪泛型，因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除。泛型的本质是参数化类型，也就是说，所操作的数据类型被指定为一个参数。\n\n## 泛型带来的好处\n在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。\n\n泛型的好处在于其提供了编译时的类型安全检测机制，该机制允许程序员在编译时检测到非法的类型，并且所有的强制转换都是自动和隐式的。\n\n## 泛型的使用方式\n泛型一般有三种使用方式：泛型类、泛型接口、泛型方法。\n### 泛型类\n```java\n// 定义\npublic class Demo<T> {\n    private T type;\n\n    public Demo(T type) {\n        this.type = type;\n    }\n\n    public T getType() {\n        return type;\n    }\n}\n\n// 实例化\nDemo<Integer> demo = new Demo<Integer>(1234);\n```\n### 泛型接口\n```java\n// 定义\npublic interface Demo<T> {\n    public T setType();\n    public T getType();\n}\n\n// 实现\npublic class DemoImpl<T> implements Demo<T> {\n    @Override\n    public T setType() {\n        return null;\n    }\n\n    @Override\n    public T getType() {\n        return null;\n    }\n}\n```\n\n### 泛型方法\n```java\n// 定义\npublic static <T> void doSomthing(T t) {\n    System.out.println(t.getClass());\n}\n\n// 使用\ndoSomthing(\"aa\");\n```\n\n## 常用的通配符 T，E，K，V，？\n* ？ 表示不确定的 java 类型，也称为无界通配符\n* T (type) 表示具体的一个 java 类型\n* K V (key value) 分别代表 java 键值中的 Key Value\n* E (element) 代表 Element\n\n#### 上界通配符\n`<? extends Animal>`，`<T extends Animal>`，`<K extends Animal>`，`<V extends Animal>`，`<E extends Animal>`\n\n#### 下界通配符\n`<? super Animal>`\n\n#### ？ 和 T 的区别\n* ？和 T 都表示不确定的类型，第1个区别在于我们可以对 T 进行操作，但是对 ？ 不行，比如如下这种：\n    ```java\n    // 可以\n    T t = doSomething();\n    t.toString();\n\n    // 不可以\n    ？ d = doSomething();\n    d.toString();\n    ```\n* 第2个区别在于可以通过 T 来 确保泛型参数的一致性，而 ？ 不行：\n    ```java\n    // 通过 T 来确保泛型参数的一致性\n    public <T extends Animal> void doSomething(List<T> dest, List<T> src)\n\n    // ？通配符表示不确定的类型，所以这个方法不能保证两个 List 具有相同的元素类型\n    public void doSomething(List<? extends Animal> dest, List<? extends Animal> src)\n    ```\n* 第3个区别在于 T 类型参数可以多重限定而 ？ 通配符不行：\n    ```java\n    public <T extends AnimalA & AnimalB> void doSomething(T t)\n    ```\n* 第4个区别在于 T 类型参数只支持上界通配符，而 ？ 通配符同时支持上界通配符和下界通配符\n    ```java\n    T extends Animal\n\n    ? extends Animal\n    ? super Animal\n    ```\n\n#### `Class<T>` 和 `Class<?>` 区别\n```java\n// 不会报错\npublic class Demo {\n    public Class<?> doGetClass() {\n        return null;\n    }\n}\n\n// 会报错，因为 T 需要指定类型\npublic class Demo {\n    public Class<T> doGetClass() {\n        return null;\n    }\n}\n\n// 不会报错，因为当前的类已经指定了 T 类型参数\npublic class Demo<T> {\n    public Class<T> doGetClass() {\n        return null;\n    }\n}\n```", "title": "【java基础】Java泛型"}
}