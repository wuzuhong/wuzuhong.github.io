function getBlog(){
	return blog = {"content": "# 【springboot】SpringBoot底层原理\n* 参考1：https://www.cnblogs.com/xiaopotian/p/11052917.html\n* 参考2：https://www.cnblogs.com/developerxiaofeng/p/9081689.html\n\n任何一个Spring Boot项目，都会用到如下的启动类：\n```java\n@SpringBootApplication\npublic class Application {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n}\n```\n\n## 注解`@SpringBootApplication`\n`@SpringBootApplication`注解是Spring Boot的核心注解，它主要包括三个重要的注解：\n\n#### `@Configuration`\n用于标识当前启动类本身也是一个IoC容器的配置类\n\n#### `@ComponentScan`\n用于自动扫描并加载符合条件的Bean定义（比如@Controller、@Service、@Repository、@Component和@Configuration等等），最终将这些Bean定义加载到IoC容器中。可以通过它的basePackages属性来细粒度的定制@ComponentScan自动扫描的包路径，如果不指定，则默认会对声明@ComponentScan所在类的包及其子包进行扫描，所以SpringBoot的启动类最好是放在最顶级的包路径下，因为默认不指定basePackages\n\n#### `@EnableAutoConfiguration`\n平时会用到一些常用的以@Enable开头的注解，如：@EnableScheduling、@EnableCaching等等，@EnableAutoConfiguration注解的原理和它们类似，简单概括一下就是，借助@Import的支持，收集和注册特定场景相关的bean定义（所以@Import也是一种加载bean的方式）。\n\n@EnableAutoConfiguration 就是利用 @Import 注解将 EnableAutoConfigurationImportSelector 类注册进来的。借助EnableAutoConfigurationImportSelector，可以将所有符合条件的@Configuration配置类都加载到当前SpringBoot创建并使用的IoC容器中，这借助于Spring框架原有的一个工具类SpringFactoriesLoader的支持，**这也是SpringBoot的自动配置的底层原理**（例如：添加了spring-boot-starter-web依赖后，Spring Boot就会对Tomcat和Spring MVC进行自动配置）。\n\nSpringFactoriesLoader体现了SpringBoot的“约定大于配置”的理念，它能加载当前工程包及其依赖包下的所有`META-INF/spring.factories`配置文件（这个文件就是用来定义@Configuration配置类的全路径的），`META-INF/spring.factories`就是它的约定，这个文件也是那些Starter最重要的部分。\n\n这里可能会有一个疑问，有了 @ComponentScan 为什么还要 EnableAutoConfigurationImportSelector ？答案是：无法限制所有依赖包下的 @Configuration 配置类都放在特定包下。\n\n## 类定义`SpringApplication.run(Application.class, args)`\n这个run方法的主要流程大体可以归纳如下：\n\n* 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：\n  * 根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。\n  * 使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。\n  * 使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。\n  * 推断并设置main方法的定义类。\n\n* SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。\n\n* 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。\n\n* 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。\n\n* 如果SpringApplication的showBanner属性被设置为true，则打印banner。\n\n* 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。\n\n* ApplicationContext创建好之后，SpringApplication会再次借助SpringFactoriesLoader，查找并加载classpath中所有可用的ApplicationContextInitializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。\n\n* 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。\n\n* 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。\n\n* 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。\n\n* 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。\n\n* 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。\n\n* 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）\n\n去除事件通知点后，整个流程如下：\n![启动流程](./images/springboot-startup.jpg)\n\n## spring-boot-autoconfigure包的作用\n这个包的maven坐标为：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-autoconfigure</artifactId>\n</dependency>\n```\n这个包里面主要是包含了很多的自动配置类，包括：数据源的自动配置、Jersey的自动配置、邮件的自动配置、日志的自动配置等等\n\n## 对 ServletInitializer 的理解\n在war工程中通常会有一个ServletInitializer类：\n```java\npublic class ServletInitializer extends SpringBootServletInitializer {\n\t@Override\n\tprotected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n\t\treturn application.sources(Application.class);\n\t}\n}\n```\n在启动服务器的时候，jar包和war包启动的区别在于：\n* jar包：执行SpringBootApplication的run方法,启动IOC容器,然后创建嵌入式Servlet容器\n* war包：先是启动Servlet服务器，然后服务器通过执行SpringBootServletInitializer类来启动Springboot应用，然后启动IOC容器\n\n在 Servlet 3.0 开始，web服务器启动后，会自动创建当前web应用里面所有jar包里面的`ServletContainerlnitializer`实例并调用其`onStartup`方法，这个实例的所属类可以通过`META-INF/services/javax.servlet.ServletContainerInitializer`来指定。\n\nSpringBoot利用了 Servlet 3.0 这个规则，在`spring-web`包下可以找到`META-INF/services/javax.servlet.ServletContainerInitializer`这个文件，其内容为`org.springframework.web.SpringServletContainerInitializer`，相当于在web服务器启动后会自动加载SpringServletContainerInitializer类，这个类声明了一个注解`@HandlesTypes(WebApplicationInitializer.class)`，相当于在web服务器启动后也会加载WebApplicationInitializer接口的实现类，而ServletInitializer所继承的SpringBootServletInitializer类刚好就实现了WebApplicationInitializer接口。\n\n这也是为什么在SpringBoot中已经没有了web.xml，因为ServletContainerInitializer是提供了一个实现和web.xml类似功能的接口，在应用启动的时候能够通过编程的方式来注册Servlet、Fileter、Listener的功能。", "title": "【springboot】SpringBoot底层原理"}
}