function getBlog(){
	return blog = {"content": "# 【springboot】HelloWorld\n## 概述\nSpring Boot使创建独立的、基于生产级Spring的应用程序变得很容易，并且允许直接运行这些应用程序。它具有以下特性：\n* JavaWeb应用程序的一站式开发框架。\n* 支持内嵌Tomcat、Jetty以及Netty，不需要去单独部署war包。\n* 提供自定义的starter（启动器）依赖项，以简化构建配置。\n* 尽可能的自动配置spring和第三方库。\n* 提供可用于生产的特性，如指标数据、健康检查和外部配置。\n* 不需要xml配置。\n\n## HelloWorld\n常用springboot文件目录\n\n![springboot-catalog](./images/springboot-catalog.jpg)\n\n### 创建一个springboot项目\n普通maven项目可以通过添加springboot相关maven依赖来创建springboot项目，因为springboot本来就是maven项目，但为了简化创建springboot项目的过程，idea和eclipse允许我们在界面上选择我们需要的maven依赖。\n\n### maven依赖\n```xml\n  <!--springboot的版本控制中心，用于管理springboot应用中所有依赖的版本，\n    因此一般情况下我们导入的依赖是不需要声明版本号的-->\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.1.3.RELEASE</version>\n    <relativePath/> <!-- lookup parent from repository -->\n  </parent>\n  <dependencies>\n    <!--web启动器（必选），帮助我们导入web模块正常运行的所有依赖及其默认配置-->\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n\n    <!--tomcat启动器（必选），帮助我们导入内置tomcat服务器所需要的所有依赖及其默认配置-->\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-tomcat</artifactId>\n      <scope>provided</scope>\n    </dependency>\n    <!--单元测试启动器（可选），帮助我们导入单元测试所需要的所有依赖及其默认配置-->\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-test</artifactId>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n\n  <!--springboot的maven插件（必选）-->\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n      </plugin>\n    </plugins>\n  </build>\n```\n\n### 主入口类\n```java\n/**\n * @SpringBootApplication 标注一个主入口类并说明这是一个Spring Boot应用，\n * 同时它也是一个组合注解，它包含了以下几个注解的功能：\n * @SpringBootConfiguration 用于标明当前类是一个配置类，就像xml配置文件，而现在是用java代码来配置，效果是一样的；\n * @EnableAutoConfiguration 开启自动配置，用于将spring的 @Enable* 系列注解全部包含进来而无需开发者显式声明，其中就包括了用于开启事务的注解，因此只需要在我们想要添加事务的方法上加上 @Transactional 注解即可开启事务；\n * @ComponentScan 用于实现自动扫描注解（包括@Controller、@RestController、@Service、@Component等等一系列的Spring注解），默认会扫描当前包和所有子包，和 xml 配置自动扫描效果一样；\n * @Filter 用于排除两个系统类。\n*/\n@SpringBootApplication\npublic class StudySpringbootApplication {\n\n  public static void main(String[] args) {\n    SpringApplication.run(StudySpringbootApplication.class, args);\n  }\n\n}\n```\n运行主入口类中的main函数即可启动服务。\n\n### controller\n```java\n/**\n * @RestController 包含 @Controller 和 @ResponseBody 两个注解，可以将返回值自动转为 JSON\n*/\n@RestController\npublic class DemoController {\n    @GetMapping(\"/demo\")\n    public Map<String, String> demo() {\n        Map<String, String> result = new HashMap<String, String>();\n        result.put(\"msg\", \"haha\");\n        return result;\n    }\n}\n```\n\n### service\n```java\n@Service\npublic class DemoService {\n  public Map<String, String> demoFunc(Integer id) {\n    //业务代码\n    return null;\n  }\n}\n```\n\n### 不采用内嵌的服务器，而使用外部服务器来单独部署war包\n如果使用内嵌的服务器，则直接使用jar包，运行主入口类的main函数即可，但有时考虑到性能优化问题，并且内嵌的服务器不支持jsp，于是就需要使用外部服务器来部署，这时就需要将程序打成war包，此时需要编写一个SpringBootServletInitializer的子类，并重写其中的configure方法：\n```java\npublic class ServletInitializer extends SpringBootServletInitializer {\n  @Override\n  protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n    return application.sources(StudySpringbootApplication.class);\n  }\n}\n```\n然后将tomcat的maven依赖的scope改为provided即可。\n\n## springboot 常用的注解\n使用了这些注解后就会在容器启动的时候就被 springboot 加载，前提是这些类必须在主入口类所在包或其子包下\n* @Controller：标明这时一个 controller\n* @RestController：标明这是一个 controller，包含 @Controller 和 @ResponseBody 两个注解，可以将返回值自动转为 JSON\n* @Service：标明这是一个 service 类，通常放在 service 的实现类中\n* @Configuration：标明这是一个配置类，相当于原始的配置文件\n* @Component：标明这是一个 controller 类、service 类和配置类以外的组件，常用于需要在容器启动的时候就被 springboot 加载的类", "title": "【springboot】HelloWorld"}
}