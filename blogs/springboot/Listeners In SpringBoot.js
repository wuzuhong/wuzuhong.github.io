function getBlog(){
	return blog = {"content": "# 【springboot】SpringBoot中的各类监听器\n\n## `SpringBoot`的全生命周期监听器`SpringApplicationRunListener`\n\n#### 实现`SpringApplicationRunListener`接口\n```java\npublic class DemoSpringApplicationRunListener implements SpringApplicationRunListener {\n    // 必须要有这个构造函数，因为需要根据指定类型的构造方法来初始化类\n    public DemoSpringApplicationRunListener(SpringApplication springApplication, String[] args) {\n    }\n\n    public void starting(ConfigurableBootstrapContext bootstrapContext) {\n        System.out.println(\"starting\");\n    }\n\n    public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) {\n        System.out.println(\"environmentPrepared\");\n    }\n\n    public void contextPrepared(ConfigurableApplicationContext context) {\n        System.out.println(\"contextPrepared\");\n    }\n\n    public void contextLoaded(ConfigurableApplicationContext context) {\n        System.out.println(\"contextLoaded\");\n    }\n\n    public void started(ConfigurableApplicationContext context) {\n        System.out.println(\"started\");\n    }\n\n    public void running(ConfigurableApplicationContext context) {\n        System.out.println(\"running\");\n    }\n\n    public void failed(ConfigurableApplicationContext context, Throwable exception) {\n        System.out.println(\"failed\");\n    }\n}\n```\n\n#### 在`src/main/resources/META-INF/spring.factories`中定义实现类的全路径以生效\n```\norg.springframework.boot.SpringApplicationRunListener=\\\n  com.example.demo.DemoSpringApplicationRunListener\n```\n\n`注意：SpringApplicationRunListener属于应用程序启动层面的监听器，在SpringBoot启动时候，调用run方法进行反射加载初始化。此时上下文还没有加载，所以通过@Component是起不了作用的。`\n\n## 应用上下文事件监听器`ApplicationListener`\n如果容器中有一个`ApplicationListener`的`Bean`，每当`ApplicationContext`发布`ApplicationEvent`时，`ApplicationListener`的`Bean`中的`onApplicationEvent`方法将自动被触发。监听的事件类型由`ApplicationListener`中的泛型决定，`ApplicationListener`中的常见泛型有：\n* `ContextRefreshedEvent`：ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext接口中使用 refresh() 方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，ApplicationContext容器已就绪可用。\n* `ContextStartedEvent`：当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。\n* `ContextStoppedEvent`：当使用 ConfigurableApplicationContext 接口中的 stop() 停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。\n* `ContextClosedEvent`：当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端，它不能被刷新或重启。\n* `RequestHandledEvent`：这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件。\n\n#### 实现`ApplicationListener`接口以接收`ContextRefreshedEvent`事件\n```java\n@Component\npublic class DemoApplicationListener implements ApplicationListener<ContextRefreshedEvent> {\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {\n        System.out.println(\"onContextRefreshedEvent\");\n    }\n}\n```\n\n#### 发布`ContextRefreshedEvent`事件\n```java\n@RestController\npublic class DemoController {\n    @Autowired\n    private ApplicationContext applicationContext;\n\n    @GetMapping(\"publish\")\n    public String publish() {\n        applicationContext.publishEvent(new ContextRefreshedEvent(applicationContext));\n        return \"true\";\n    }\n}\n```\n\n### 自定义事件\n* 自定义事件对象\n    ```java\n    public class DemoEvent extends ApplicationEvent {\n        private String msg;\n        public DemoEvent(Object source) {\n            super(source);\n        }\n        public DemoEvent(Object source, String msg) {\n            super(source);\n            this.msg = msg;\n        }\n        public String getMsg() {\n            return msg;\n        }\n        public void setMsg(String msg) {\n            this.msg = msg;\n        }\n    }\n    ```\n* 发布自定义事件\n    ```java\n    @RestController\n    public class DemoController {\n        @Autowired\n        private ApplicationContext applicationContext;\n\n        @GetMapping(\"/publish\")\n        public String publish() {\n            applicationContext.publishEvent(new DemoEvent(applicationContext, \"haha\"));\n            return \"true\";\n        }\n    }\n    ```\n* 接收自定义事件\n    ```java\n    @Component\n    public class DemoApplicationListener implements ApplicationListener<DemoEvent> {\n        @Override\n        public void onApplicationEvent(DemoEvent demoEvent) {\n            System.out.println(demoEvent.getMsg());\n        }\n    }\n    ```\n\n## `ServletContext`生命周期的监听器`ServletContextListener`，它是属于`Servlet`容器，不属于`SpringBoot`\n\n#### 实现`ServletContextListener`接口\n```java\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\nimport javax.servlet.annotation.WebListener;\n\n@WebListener //自动注册ServletContextListener，需要配合@ServletComponentScan来使用\npublic class DemoServletContextListener implements ServletContextListener {\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println(\"contextInitialized\");\n    }\n\n    public void contextDestroyed(ServletContextEvent sce) {\n        System.out.println(\"contextDestroyed\");\n    }\n}\n```\n\n#### 在`SpringBoot`启动类中添加扫描注解`@ServletComponentScan`\n```java\n@SpringBootApplication\n@ServletComponentScan //默认扫描当前包及所有子包\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n\n}\n```", "title": "【springboot】SpringBoot中的各类监听器"}
}