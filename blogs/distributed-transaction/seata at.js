function getBlog(){
	return blog = {"content": "# 【微服务—分布式事务解决方案】Seata中的AT模式\n* 参考1：https://seata.io/zh-cn/docs/overview/what-is-seata.html\n\nSeata中的AT模式是两阶段提交协议的演变：\n* 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。\n* 二阶段：\n  * 提交异步化，非常快速地完成。\n  * 回滚通过一阶段的回滚日志（undo log）进行反向补偿。\n\n## 前提\n* 基于支持本地 ACID 事务的关系型数据库\n* Java 应用，通过 JDBC 访问数据库\n\n## 写隔离\n* 一阶段本地事务提交前，需要确保先拿到**全局锁**。\n* 拿不到**全局锁**，不能提交本地事务。\n* 拿**全局锁**的尝试被限制在一定时间范围内，超出这个时间范围将自动放弃，并回滚本地事务，释放本地锁。\n\n#### 示例\n假设现在有两个事务参与者 tx1 和 tx2 ，那么它们将会进行以下步骤：\n1. 事务参与者 tx1 和 tx2 分别开启本地事务，拿到本地锁，并进行业务操作，这一步骤可能是按顺序执行的，也可能是同时执行的\n2. 在本地事务提交前，事务参与者 tx1 和 tx2 会向事务协调者请求**全局锁**，这一步骤是有顺序的，假设 tx1 先拿到，tx2 将会重试等待**全局锁**\n3. tx1 拿到**全局锁**后，进行一阶段提交，提交本地事务并释放本地锁\n4. tx1 进行二阶段提交，释放**全局锁**\n5. tx2 拿到**全局锁**，进行一阶段提交，提交本地事务并释放本地锁\n6. tx2 进行二阶段提交，释放**全局锁**，至此就结束了。\n\n以上示例中的 1、2、3 步骤报错后，是由各个事务参与者的数据库自行回滚。\n\n以上示例中的 4 步骤报错后， tx1 需要重新获取该数据的本地锁，进行反向补偿，实现分支的回滚，但是如果此时 tx2 仍在等待该数据的**全局锁**，同时持有本地锁，则 tx1 的分支回滚会失败，并且会一直重试，直到 tx2 的**全局锁**等锁超时，放弃**全局锁**并回滚 tx2 本地事务并释放本地锁，然后 tx1 的分支回滚才会最终成功。\n\n因为整个过程**全局锁**在 tx1 结束前一直是被 tx1 持有的，所以不会发生**脏写**的问题。\n\n## 读隔离\n在数据库本地事务隔离级别**读已提交（Read Committed）**或以上的基础上，Seata中的AT模式的默认全局隔离级别是**读未提交（Read Uncommitted）**。\n\n如果应用在特定场景下，必需要求全局的**读已提交**，目前 Seata 的方式是通过对`SELECT FOR UPDATE`语句进行代理。\n\n`SELECT FOR UPDATE`语句的执行会申请**全局锁**，如果**全局锁**被其他事务持有，则释放本地锁（回滚`SELECT FOR UPDATE`语句的本地执行）并重试。这个过程中，查询是被阻塞住的，直到**全局锁**拿到，即读取的相关数据是**已提交**的，才返回。\n\n出于总体性能上的考虑，Seata目前的方案并没有对所有`SELECT`语句都进行代理，仅针对`FOR UPDATE`的`SELECT`语句。\n", "title": "【微服务—分布式事务解决方案】Seata中的AT模式"}
}