# 【微服务—分布式事务解决方案】Seata中的AT模式
* 参考1：https://seata.io/zh-cn/docs/overview/what-is-seata.html

Seata中的AT模式是两阶段提交协议的演变：
* 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
* 二阶段：
  * 提交异步化，非常快速地完成。
  * 回滚通过一阶段的回滚日志（undo log）进行反向补偿。

## 前提
* 基于支持本地 ACID 事务的关系型数据库
* Java 应用，通过 JDBC 访问数据库

## 写隔离
* 一阶段本地事务提交前，需要确保先拿到**全局锁**。
* 拿不到**全局锁**，不能提交本地事务。
* 拿**全局锁**的尝试被限制在一定时间范围内，超出这个时间范围将自动放弃，并回滚本地事务，释放本地锁。

#### 示例
假设现在有两个事务参与者 tx1 和 tx2 ，那么它们将会进行以下步骤：
1. 事务参与者 tx1 和 tx2 分别开启本地事务，拿到本地锁，并进行业务操作，这一步骤可能是按顺序执行的，也可能是同时执行的
2. 在本地事务提交前，事务参与者 tx1 和 tx2 会向事务协调者请求**全局锁**，这一步骤是有顺序的，假设 tx1 先拿到，tx2 将会重试等待**全局锁**
3. tx1 拿到**全局锁**后，进行一阶段提交，提交本地事务并释放本地锁
4. tx1 进行二阶段提交，释放**全局锁**
5. tx2 拿到**全局锁**，进行一阶段提交，提交本地事务并释放本地锁
6. tx2 进行二阶段提交，释放**全局锁**，至此就结束了。

以上示例中的 1、2、3 步骤报错后，是由各个事务参与者的数据库自行回滚。

以上示例中的 4 步骤报错后， tx1 需要重新获取该数据的本地锁，进行反向补偿，实现分支的回滚，但是如果此时 tx2 仍在等待该数据的**全局锁**，同时持有本地锁，则 tx1 的分支回滚会失败，并且会一直重试，直到 tx2 的**全局锁**等锁超时，放弃**全局锁**并回滚 tx2 本地事务并释放本地锁，然后 tx1 的分支回滚才会最终成功。

因为整个过程**全局锁**在 tx1 结束前一直是被 tx1 持有的，所以不会发生**脏写**的问题。

## 读隔离
在数据库本地事务隔离级别**读已提交（Read Committed）**或以上的基础上，Seata中的AT模式的默认全局隔离级别是**读未提交（Read Uncommitted）**。

如果应用在特定场景下，必需要求全局的**读已提交**，目前 Seata 的方式是通过对`SELECT FOR UPDATE`语句进行代理。

`SELECT FOR UPDATE`语句的执行会申请**全局锁**，如果**全局锁**被其他事务持有，则释放本地锁（回滚`SELECT FOR UPDATE`语句的本地执行）并重试。这个过程中，查询是被阻塞住的，直到**全局锁**拿到，即读取的相关数据是**已提交**的，才返回。

出于总体性能上的考虑，Seata目前的方案并没有对所有`SELECT`语句都进行代理，仅针对`FOR UPDATE`的`SELECT`语句。
