function getBlog(){
	return blog = {"content": "# 【mysql】乐观锁和悲观锁\n\n## 实际场景\n考虑商品的下单流程，商品的库存量是固定的，如何保证商品不超卖？其实就是需要保证数据一致性：顾客点击下单后系统查出来的库存量和实际扣减库存时的库存量一致就可以了。不考虑并发的情况下，更新库存代码如下：\n```java\npublic boolean updateStockRaw(Long goodsId){\n    Goods goods = query(\"SELECT * FROM tb_goods WHERE goods_id=#{goodsId}\", goodsId);\n    if (goods.getNumber() > 0) {\n        int updateCnt = update(\"UPDATE tb_goods SET number=number-1 WHERE goods_id=#{goodsId} AND number=#{number}\", goodsId, goods.getNumber());\n        if(updateCnt > 0){    //更新库存成功\n            return true;\n        }\n    }\n    return false;\n}\n```\n多线程并发情况下，以上代码就会存在超卖的可能性。\n\n## 悲观锁\n顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。Java的synchronized关键字就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。\n\n#### MySQL隐式和显示锁定\nMySQL InnoDB支持行级锁，可以通过特定的语句进行显示行级锁定：SELECT … FOR UPDATE\n\n```java\npublic boolean updateStock(Long goodsId){\n    // 使用 SELECT FOR UPDATE 为查询出来的商品记录加上行级锁，直到下一次更新才会释放这个行级锁\n    Goods goods = query(\"SELECT * FROM tb_goods WHERE goods_id=#{goodsId} FOR UPDATE\", goodsId);\n    if (goods.getNumber() > 0) {\n        int updateCnt = update(\"UPDATE tb_goods SET number=number-1 WHERE goods_id=#{goodsId}\", goodsId);\n        if(updateCnt > 0){    //更新库存成功\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n## 乐观锁\n顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。一般来说有以下2种方式： \n1. 使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。 \n2. 使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。\n\nJava中atomic包就是乐观锁的一种实现，AtomicInteger 通过CAS（Compare And Set）操作实现线程安全的自增。\n\n```java\npublic boolean updateStock(Long goodsId){\n    int updateCnt = 0;\n    while (updateCnt == 0) {\n        Goods goods = query(\"SELECT * FROM tb_goods WHERE goods_id=#{goodsId}\", goodsId);\n        if (goods.getNumber() > 0) {\n            updateCnt = update(\"UPDATE tb_goods SET number_=#{number}, version=#{version} WHERE goods_id=#{goodsId} AND version=#{oldVersion}\", goods.getNumber() - 1, goods.getVersion() + 1, goods.getVersion());\n            if(updateCnt > 0){    //更新库存成功\n                return true;\n            }\n        } else {    //卖完啦\n            return false;\n        }\n    }\n    return false;\n}\n```\n使用乐观锁更新库存的时候不加锁，当提交更新时需要判断数据是否已经被修改（AND version=#{oldVersion}），只有在 version 等于上一次查询到的 version 时才提交更新，否则就进行循环。\n\n## 乐观锁与悲观锁的区别\n乐观锁的思路一般是表中增加版本字段，更新时where语句中增加版本的判断，算是一种CAS（Compare And Swep）操作，商品库存场景中 version 起到了版本控制的作用（AND version=#{oldVersion}）。\n\n悲观锁之所以是悲观，在于他认为本次操作会发生并发冲突，所以一开始就对商品加上锁（SELECT … FOR UPDATE），然后就可以安心的做判断和更新，因为这时候不会有别人更新这条商品库存。\n\n从中可以知道只要更新数据是依赖读取的数据作为基础条件的，就会有并发更新问题，需要乐观锁或者悲观锁去解决，特别是在计数表现明显。又比如在更新数据不依赖查询的数据的就不会有问题，例如修改用户的名称，多人同时修改，结果并不依赖于之前的用户名字，这就不会有并发更新问题。\n\n**乐观锁和悲观锁适用于：依赖读取的数据作为基础条件的更新场景**  \n**幂等性适用于：有唯一性业务需求的新增场景**", "title": "【mysql】乐观锁和悲观锁"}
}